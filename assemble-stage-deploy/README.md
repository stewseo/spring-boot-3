## Releasing a Spring Boot Application

This project's goal is to demonstrate how to :
- Assemble an application
  - Create an uber JAR
  - Bake a Docker container
- Stage an application
  - Release our application to Docker Hub
- Manage an application once deployed
  - Tweak things in production

### Create an uber JAR

#### Build an uber JAR to quickly move the code out of our IDE and onto the production servers
```
# clean: Deletes that targetfolder and any other generated outputs. This is always good to include before building an uber JAR to ensure all generated outputs are up-to-date.
# package: Invokes Maven’s package phase, which will cause the verify, compile, and test phases to be invoked in the proper order.
% ./mvnw clean package
```
```
# clean: deletes a build directory, all project classes will be removed for a fresh compile.
# build: builds your Gradle project, including assembling your application and running tests
$ ./gradlew clean build
```
- The mvnw and gradlew scripts only works on Mac or Linux machine. If you’re on Windows, you either must have a comparable shell environment, or you can use ./mvnw.cmd or ./gradlew.cmd instead.

#### Apply plugin that hooks into Maven’s package phase/Gradle's build phase
```
<plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
</plugin>
```
```
plugins {
    id "org.springframework.boot" version "3.0.4"
}
```
1. It grabs the JAR file originally generated by standard Maven packaging procedures (target/projectname-version-SNAPSHOT.jar) and extracts all of its content.
2. Then, it renames the original JAR to set it aside (target/projectname-version-SNAPSHOT.jar.original).
3. It fashions a new JAR file with the original name.
4. In the new JAR file, it adds the Spring Boot loader coder, which is glue code that can read JAR files from within, allowing it to become a runnable JAR file.
5. It adds our application code to the new JAR file in a subfolder called BOOT-INF.
6. It adds ALL of our application’s third-party dependency JARs into this JAR file in a subfolder called BOOT-INF/lib.
7. Finally, it adds some metadata about the layers of the application to this JAR file underneath BOOT-INF as classpath.idx and layers.idx


#### Run an application on any machine with the right Java Development Kit(JDK). Spring Boot simply lets our code run as if the third-party JAR files are there as always. No shading is required.
```
% java -jar target/projectname-version.jar
```
- There is no need to download and install an Apache Tomcat servlet container anywhere. We are using embedded Apache Tomcat. This means this tiny JAR file is carrying the means to run itself.
- There is no need to go through the legacy procedure of installing an application server, fashioning a WAR file, combining it with third-party dependencies using some ugly assembly file to fashion an EAR file, and then uploading the whole thing to some atrocious UI.
- We can push this whole thing to our favorite cloud provider and command the system to run 10,000 copies.

### Baking a Docker container

#### Assuming you have installed Docker on your machine, instead of connecting to any particular phase of Maven’s build and deploy life cycle, the Spring Boot Maven plugin will execute a custom task to bake a container.
```
% ./mvnw spring-boot:build-image
```
- Baking a container is a Docker phrase meaning assembling all the parts needed to run a container. Baking implies that we only need to generate the image of this container once, and we can then reuse it as many times as needed to run as many instances as required.
- When Spring Boot does a build-image process, it first runs Maven’s package phase. This includes running the standard complement of unit tests. After that, it will assemble the uber JAR we talked about in the previous section.


### Leveraging Paketo Buildpacks to pull the right type of container together.

- Docker has a caching solution built into it that involves layers. If a given step in building a container sees no changes from the previous container assembly process, it will use the Docker engine’s caching layer.
- However, if some aspect has changed, it will invalidate the cached layer and create a new one.

#### Run ./gradlew :spring-boot-deployment:bootBuildImage:
```
Building image 'docker.io/library/spring-boot-deployment:1.0-SNAPSHOT'

 > Pulling builder image 'docker.io/paketobuildpacks/builder:base' ..................................................
 > Pulled builder image 'paketobuildpacks/builder@sha256:7bfb7dd1c7f7a492926ca07bcea36b1585b0bfa5afba23d8c7e9e990c767228d'
 > Pulling run image 'docker.io/paketobuildpacks/run:base-cnb' ..................................................
 > Pulled run image 'paketobuildpacks/run@sha256:346b4c5aa3ab7a12b7595af346e875da584d4fa58df919e3b04355da4131558f'
 > Executing lifecycle version v0.16.0
 > Using build cache volume 'pack-cache-0c9d8b4c8ff3.build'
…
Successfully built image 'docker.io/library/spring-boot-deployment:1.0-SNAPSHOT'
```
- Builds an image using Docker, named docker.io/library/spring-boot-deployment:1.0-SNAPSHOT This includes the name of our module as well as the version, both found in our pom.xml file.
- Pulls the paketobuildpacks/builderand paketobuildpacks/runcontainers to use the Paketo Buildpack from Docker Hub
  - a project focused on turning application source code into container images. Instead of doing it directly, Spring Boot delegates containerization to Paketo. Essentially, it downloads containers that do all the leg work, easing the process for us to bake a container.
- A Successfully assembled container is the result.

#### Run the fully assembled container using Docker
```
$ docker run -p 8080:8080 docker.io/library/spring-boot-deployment:1.0-SNAPSHOT
Setting Active Processor Count to 16
Calculating JVM memory based on 2719948K available memory
For more information on this calculation, see https://paketo.io/docs/reference/java-reference/#memory-calculator
Calculated JVM Memory Configuration: -XX:MaxDirectMemorySize=10M -Xmx2304208K -XX:MaxMetaspaceSize=108539K -XX:ReservedCodeCacheSize=240M -Xss1M (Total Memory: 2719948K, Thread Count: 50, Loaded Class Count: 16749, Headroom: 0%)
Enabling Java Native Memory Tracking
Adding 124 container CA certificates to JVM truststore
Spring Cloud Bindings Enabled
...



 :: Spring Boot ::                (v3.0.4)

2023-03-14T02:26:33.287Z  INFO 1 --- [           main] .e.s.b.d.SpringBootDeploymentApplication : Starting SpringBootDeploymentApplication v1.0-SNAPSHOT using Java 17.0.6 with PID 1 (/workspace/BOOT-INF/classes started by cnb in /workspace)
```
- docker run: The command to run a Docker container
- -p 8080:8080: An argument that maps the container’s inner port number 8080 to everyone outside the container on port 8080
- docker.io/library/ch7:0.0.1-SNAPSHOT: The name of the container’s image

#### docker ps is a command that shows any running Docker processes.
```
$ docker ps
CONTAINER ID   IMAGE                                 COMMAND              CREATED          STATUS          PORTS                    NAMES
ca744db04211   spring-boot-deployment:1.0-SNAPSHOT   "/cnb/process/web"   10 minutes ago   Up 10 minutes   0.0.0.0:8080->8080/tcp   flamboyant_easley
```
- ca744db04211: The hashed ID of the container.
- spring-boot-deployment:1.0-SNAPSHOT: The name of the container’s image (without the docker.io prefix)
- /cnb/process/web: The command the Paketo Buildpack is using to run our Spring Boot application.
- "10 minutes ago " and "Up 10 minutes": When the container started and how long it’s been up.
- 0.0.0.0:8080->8080/tcp: The internal to external network mapping.
- flamboyant_easley: The human-friendly name Docker has given this container’s instance. You can refer to an instance by either the hash code or this.

```
$ docker stop flamboyant_easley
flamboyant_easley

$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```
- This shuts the whole container down. We can see it on the console where we launched everything.