## Releasing a Spring Boot Application

#### This project's goal is to demonstrate how to:
- Turn our application from a collection of code into an executable, ready for any production environment, including the cloud:
  - Creating an uber JAR that is runnable anywhere.
  - Baking a Docker container image that can be run locally with no need for Java.
  - Pushing our Docker container to Docker Hub where it can be consumed by our clients.
- Manage/tune/tweak applications once deployed so that we could scale it up as needed:
  - Running multiple instances of our uber JAR pointed at a persistent database, different than the one it came bundled with.

### Creating an uber JAR that is runnable anywhere

#### Build an uber JAR to quickly move the code out of our IDE and onto the production servers
```
# clean: Deletes that targetfolder and any other generated outputs. This is always good to include before building an uber JAR to ensure all generated outputs are up-to-date.
# package: Invokes Maven’s package phase, which will cause the verify, compile, and test phases to be invoked in the proper order.
% ./mvnw clean package
```
```
# clean: deletes a build directory, all project classes will be removed for a fresh compile.
# build: builds your Gradle project, including assembling your application and running tests
$ ./gradlew clean build
```
- The mvnw and gradlew scripts only works on Mac or Linux machine. If you’re on Windows, you either must have a comparable shell environment, or you can use ./mvnw.cmd or ./gradlew.cmd instead.

#### Apply plugin that hooks into Maven’s package phase/Gradle's build phase
```
<plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
</plugin>
```
```
plugins {
    id "org.springframework.boot" version "3.0.4"
}
```
1. Grabs the JAR file originally generated by standard Maven packaging procedures (target/projectname-version-SNAPSHOT.jar) and extracts all of its content.
2. Renames the original JAR to set it aside (target/projectname-version-SNAPSHOT.jar.original).
3. Fashions a new JAR file with the original name.
4. In the new JAR file, it adds the Spring Boot loader coder, which is glue code that can read JAR files from within, allowing it to become a runnable JAR file.
5. Adds our application code to the new JAR file in a subfolder called BOOT-INF.
6. Adds ALL of our application’s third-party dependency JARs into this JAR file in a subfolder called BOOT-INF/lib.
7. Adds some metadata about the layers of the application to this JAR file underneath BOOT-INF as classpath.idx and layers.idx

#### Run an application on any machine with the right Java Development Kit(JDK) Spring Boot lets our code run as if the third-party JAR files are there as always. No shading is required.
```
% java -jar target/projectname-version.jar
```
- This tiny JAR file is carrying the means to run itself, embedded Apache Tomcat. No additional Apache Tomcat servlet container is needed.
- There is no need to go through the legacy procedure of installing an application server, fashioning a WAR file, combining it with third-party dependencies using some assembly file to fashion an EAR file, and then uploading the whole thing to some UI.
- We can push this whole thing to our cloud provider and command the system to run 10,000 copies.


### Baking a Docker container

#### Spring Boot Maven plugin / Gradle Spring Boot plugin executing a custom task to bake a container instead of connecting to any particular phase of Maven’s/Gradle's build and deploy life cycle
```
% ./mvnw spring-boot:build-image
$ ./gradlew :spring-boot-deployment:bootBuildImage
```
- Baking a container is a Docker phrase meaning assembling all the parts needed to run a container. Baking implies that we only need to generate the image of this container once, and we can then reuse it as many times as needed to run as many instances as required.
- When Spring Boot does a build-image process, it first runs Maven’s package phase. This includes running the standard complement of unit tests. After that, it will assemble the uber JAR.


### Leveraging Paketo Buildpacks to pull the right type of container together.

- Docker has a caching solution built into it that involves layers. If a given step in building a container sees no changes from the previous container assembly process, it will use the Docker engine’s caching layer.
- However, if some aspect has changed, it will invalidate the cached layer and create a new one.

#### Run ./gradlew :spring-boot-deployment:bootBuildImage:
```
Building image 'docker.io/library/spring-boot-deployment:1.0-SNAPSHOT'
 > Pulling builder image 'docker.io/paketobuildpacks/builder:base' ..................................................
 > Pulled builder image 'paketobuildpacks/builder@sha256:7bfb7dd1c7f7a492926ca07bcea36b1585b0bfa5afba23d8c7e9e990c767228d'
 > Pulling run image 'docker.io/paketobuildpacks/run:base-cnb' ..................................................
 > Pulled run image 'paketobuildpacks/run@sha256:346b4c5aa3ab7a12b7595af346e875da584d4fa58df919e3b04355da4131558f'
 > Executing lifecycle version v0.16.0
 > Using build cache volume 'pack-cache-0c9d8b4c8ff3.build'
…
Successfully built image 'docker.io/library/spring-boot-deployment:1.0-SNAPSHOT'
```
- Builds an image using Docker, named docker.io/library/spring-boot-deployment:1.0-SNAPSHOT This includes the name of our module as well as the version, both found in our pom.xml file.
- Pulls the paketobuildpacks/builderand paketobuildpacks/runcontainers to use the Paketo Buildpack from Docker Hub
  - a project focused on turning application source code into container images. Instead of doing it directly, Spring Boot delegates containerization to Paketo. Essentially, it downloads containers that do all the leg work, easing the process for us to bake a container.
- A Successfully assembled container is the result.

#### Run the fully assembled container using Docker
```
$ docker run -p 8080:8080 docker.io/library/spring-boot-deployment:1.0-SNAPSHOT
Setting Active Processor Count to 16
Calculating JVM memory based on 2719948K available memory
For more information on this calculation, see https://paketo.io/docs/reference/java-reference/#memory-calculator
Calculated JVM Memory Configuration: -XX:MaxDirectMemorySize=10M -Xmx2304208K -XX:MaxMetaspaceSize=108539K -XX:ReservedCodeCacheSize=240M -Xss1M (Total Memory: 2719948K, Thread Count: 50, Loaded Class Count: 16749, Headroom: 0%)
Enabling Java Native Memory Tracking
Adding 124 container CA certificates to JVM truststore
Spring Cloud Bindings Enabled
...
 :: Spring Boot ::                (v3.0.4)
2023-03-14T02:26:33.287Z  INFO 1 --- [           main] .e.s.b.d.SpringBootDeploymentApplication : Starting SpringBootDeploymentApplication v1.0-SNAPSHOT using Java 17.0.6 with PID 1 (/workspace/BOOT-INF/classes started by cnb in /workspace)
```
- docker run: The command to run a Docker container
- -p 8080:8080: An argument that maps the container’s inner port number 8080 to everyone outside the container on port 8080
- docker.io/library/ch7:0.0.1-SNAPSHOT: The name of the container’s image

#### docker ps is a command that shows any running Docker processes.
```
$ docker ps
CONTAINER ID   IMAGE                                 COMMAND              CREATED          STATUS          PORTS                    NAMES
ca744db04211   spring-boot-deployment:1.0-SNAPSHOT   "/cnb/process/web"   10 minutes ago   Up 10 minutes   0.0.0.0:8080->8080/tcp   flamboyant_easley
```
- ca744db04211: The hashed ID of the container.
- spring-boot-deployment:1.0-SNAPSHOT: The name of the container’s image (without the docker.io prefix)
- /cnb/process/web: The command the Paketo Buildpack is using to run our Spring Boot application.
- "10 minutes ago " and "Up 10 minutes": When the container started and how long it’s been up.
- 0.0.0.0:8080->8080/tcp: The internal to external network mapping.
- flamboyant_easley: The human-friendly name Docker has given this container’s instance. You can refer to an instance by either the hash code or this.

```
$ docker stop flamboyant_easley
flamboyant_easley

$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```
- This shuts the whole container down. We can see it on the console where we launched everything.

### Releasing your application to Docker Hub
- Wrap up a completed application inside a container and release it to our users, without writing any custom code using Spring-Boot

#### Log in directly to our Docker Hub account:
```
$ docker login -u stewseo2
Password:
Login Succeeded
```

### Releasing your application to Docker Hub

#### Log in directly to our Docker Hub account:
```
$ docker login -u stewseo2
Password:
Login Succeeded
```
#### Tag and push our container, wrapped around our completed application, to the Docker Hub
```
$ docker tag spring-boot-deployment:1.0-SNAPSHOT stewseo2/spring-boot-3-spring-boot-deployment:1.0-SNAPSHOT
$ docker push stewseo2/spring-boot-3-spring-boot-deployment:1.0-SNAPSHOT
```
- docker tag <image> <tag>: Tags the local container name: "spring-boot-deployment" possessing the local tag: "1.0-SNAPSHOT" with a prefix of our Docker Hub user ID.
- The tagged container also has a name, spring-boot-3-spring-boot-deployment:1.0-SNAPSHOT
- The tagged container itself has a tag, 1.0-SNAPSHOT.
- docker push <tagged image>: Pushes the container to Docker Hub using the public-facing tagged image name

Docker Hub containers have three characteristics that go together as namespace/name:tag
- Name of the container
- Tag of the container
- Namespace of the container

![Screenshot_20230313_090435](https://user-images.githubusercontent.com/54422342/224912170-f62b9feb-6cb5-484f-9c12-87883874a7e4.png)


### Scaling with Spring Boot

If we need to host our application on ports 9000, 9001, and 9002 to match up with the load balancer:
- First, rename that local application.properties file to application-instance1.properties.
- Next, make a copy of the file and name the new one application-instance2.properties. Edit the file so that server.port is assigned 9001.
- Then, make yet another copy, this time as application-instance3.properties. This time, make its server.port have a value of 9002.

#### Run three instances using Spring Boot’s profile support. Launch instance1:
```
$ ./gradlew bootRun --args='--spring.profiles.active=instance1'
2023-03-13T21:54:58.430-07:00  INFO 7148 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 9000 (http) with context path ''
```
- Instance1 is now running on port 9000.

Open another console tab and launch instance2
```
$ ./gradlew bootRun --args='--spring.profiles.active=instance2'
2023-03-13T21:55:12.670-07:00  INFO 19592 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 9001 (http) with context path ''
```
- In this console output, we can see instance2 is running on port 9001.

#### Open a third console tab and run instance3:
```
$ ./gradlew bootRun --args='--spring.profiles.active=instance3'
2023-03-13T21:58:03.659-07:00  INFO 10812 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 9002 (http) with context path ''
```

#### We now have three instances of our application running on different ports. Buried in the first console’s output, we can see the following:
```
2023-03-13T21:54:55.137-07:00  INFO 7148 --- [           main] o.e.a.s.d.AssembleStageDeployApplication : The following 1 profile is active: "instance1"
```

Spin up a copy of PostgreSQL using Docker
```
% docker run -d -p 5432:5432 --name my-postgres -e POSTGRES_PASSWORD=postgres postgres:9.6.12
```
- -d: The instance will run as a background daemon process.
- -p 5432:5432: The standard 5432 port will be exported to the public with the same port.
- --name my-postgres: The container will run with a fixed name instead of a random one. This will prevent us from running multiple copies at the same time.
- -e POSTGRES_PASSWORD=mysecretpassword: The container will run with an environment variable that, according to Postgres’s notes, will configure the password.
- postgres:9.6.12: The same container coordinates found in the Testcontainers-based integration test.

#### Application-instance1.properties to align JDBC and JPA to communicate with the PostgreSQL database container we just spun up
```
# JDBC DataSource settings 
spring.datasource.url=jdbc:postgresql://localhost:5432/postgres 
spring.datasource.username=postgres 
spring.datasource.password=postgres
# JPA settings 
spring.jpa.hibernate.ddl-auto=update 
spring.jpa.hibernate.show-sql=true 
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect
```
JDBC properties:
- spring.datasource.url: This is the JDBC connection URL to reach the container-based instance
- spring.datasource.username: This contains the default postgres username the container runs under
- spring.datasource.password: This contains the password we picked earlier in this section
- These are all the properties needed for Spring Boot to assemble a JDBC DataSource bean.

JPA properties:
- spring.jpa.hibernate.ddl-auto: This is the Spring Data JPA setting that will update the schema if necessary, but not drop or delete anything
- spring.jpa.hibernate.show-sql: This will switch on Spring Data JPA’s ability to print out SQL statements that get generated
- spring.jpa.properties.hibernate.dialect: This is the Hibernate property that signals we are talking to a PostgreSQL-based database
